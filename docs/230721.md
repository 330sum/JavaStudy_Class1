# ☕ class 2

<br>
<br>

## 🚀 기능 요구 사항

우아한테크코스에서는 교육생(이하 크루) 간 소통 시 닉네임을 사용한다. 간혹 비슷한 닉네임을 정하는 경우가 있는데, 이러할 경우 소통할 때 혼란을 불러일으킬 수 있다.

혼란을 막기 위해 크루들의 닉네임 중 **같은 글자가 연속적으로 포함** 될 경우 해당 닉네임 사용을 제한하려 한다. 이를 위해 같은 글자가 연속적으로 포함되는 닉네임을 신청한 크루들에게 알려주는 시스템을 만들려고
한다.

신청받은 닉네임 중 **같은 글자가 연속적으로 포함** 되는 닉네임을 작성한 지원자의 이메일 목록을 return 하도록 solution 메서드를 완성하라.

### 제한사항

- 두 글자 이상의 문자가 연속적으로 순서에 맞추어 포함되어 있는 경우 중복으로 간주한다.
- 크루는 1명 이상 10,000명 이하이다.
- 이메일은 이메일 형식에 부합하며, 전체 길이는 11자 이상 20자 미만이다.
- 신청할 수 있는 이메일은 `email.com` 도메인으로만 제한한다.
- 닉네임은 한글만 가능하고 전체 길이는 1자 이상 20자 미만이다.
- result는 이메일에 해당하는 부분의 문자열을 오름차순으로 정렬하고 중복은 제거한다.

### 실행 결과 예시

| forms                                                                                                                                   | result                                              |
|-----------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------|
| [ ["jm@email.com", "제이엠"], ["jason@email.com", "제이슨"], ["woniee@email.com", "워니"], ["mj@email.com", "엠제이"], ["nowm@email.com", "이제엠"] ] | ["jason@email.com", "jm@email.com", "mj@email.com"] |

<br>
<br>


---


<br>
<br>

### 🤔 생각

1. 로직을 먼저 글로 정리해보고 접근해보기

> 접근법이 어렵다면 먼저 글로 작성한 후 글을 따라 로직을 구현해보는 것.<br>
> 처음 생각한 로직은 수정과 변경이 많으므로,<br>
> README.md 는 항상 살아있는 문서로 관리해야 한다.<br>
> 다양한 관점에서 생각을 할 땐 무엇이 득이 많고 실이 적은지 따져보자.<br>

2. 문자열을 가공하는 것에 익숙해지기

> String 클래스에서 제공하는 메서드들에 익숙해지자.<br>
> 문자열을 요구 사항에 알맞게 가공하여 로직을 처리하자.<br>
> 무언가 있을법한 기능들은 거의 다 존재하므로 열심히 찾아보자.<br>

3. 역할을 수행하는 구현체에 직접적으로 의존하지 않고 역할에 의존하라

> 구현체에 직접적으로 의존하는 것은 변경과 수정이 용이하지 않다.<br>
> 역할이라는 것을 추상화를 통해 정의해보자.<br>
> 그 후 구현체를 통해 역할의 책임을 수행하도록 한다.<br>
> 역할은 대체가 가능하다. 다른 구현체가 그 역할의 책임을 수행하더라도 어플리케이션은 잘 돌아가야 한다.<br>

4. 디미터의 법칙 & TDA 법칙(Tell, Don't ask) 묻지말고 시켜라

> 판사는 증인에게 `증언해` 라고 한다.<br>
> 증인은 `증언해` 라는 메세지에 대한 책임을 수행한다.<br>
> 어떤식으로 `증언`할 지는 증인의 자유다.<br>
> 기억을 되짚어 할 수도<br>
> 기록된 문서를 보고 할 수도 있다.<br>
> 결코 판사는 증인에게 `증언해, 기억을 되짚어서` 하지 않는다.<br>
> 결코 판사는 증인에게 `증언해, 일기장을 보고` 하지 않는다.<br>
> ```java
> String 증언 = 증인.get일기장().get사건당일().get사건시간().get증언();
> ```
> 이렇게 증언을 얻기 위해 하나하나 간섭하지 않는다.<br>
> 단순히
> ```java
> String 증언 = 증인.get증언();
> ```
> 묻지 않고 시킬 뿐이다.<br>
> `판사`라는 역할은 대체가 가능하다.<br>
> 현재 재판을 진행하는 판사 A 대신 다른 판사 B가 와도 재판을 진행하는데 문제가 없어야 한다.<br>
> `증인`의 역할도 대체가 가능하다.<br>
> `증언`이라는 책임을 수행할 수 있다면 다른 증인이 대신 증언을 해도 재판을 진행하는데 문제가 없어야 한다.<br>


5. 자료 구조

> List, Set, Queue, Deque, Map 등 다양한 자료구조를 써보자<br>
> 내부 구조 및 해당 자료 구조의 메서드들도 써보자<br>

6. 명확한 표현

> 가령
> ```java
> String name = member[0];
> ```
> member의 0번 인덱스가 무엇인지 모른다.<br>
> 명시적으로 표현해보자<br>
> ```java
> int NAME_IDX = 0;
> String name = member[NAME_IDX];
> ```


7. 자주 사용되는 객체는 재사용을 생각해보자.
> ```java
> ... nickname 에 대한 유효성 검사를 진행하는 클래스 ...
> if(!nickname.contains(REGEX)) {
>   throw new IllgalArgumentException("유효하지 않은 닉네임입니다.");
> }
> ```
> 만약, 닉네임에 정규식(특정 문자열)이 포함되어 있지 않다면 익셉션을 던진다.<br>
> REGEX 라는 객체는 정규표현식(문자열)인데<br>
> 만약 1억개의 닉네임을 검사할 때마다 객체를 생성해준다면 굉장히 비효율적이다.<br>
> 자주 사용되는 객체는 재사용을 고려해보자.